import { Set } from "immutable";
import _ from "lodash";

import { FILTER_ACTIONS } from "./constants";
import {
    IPageSuggestion,
    ISortDirection,
    ISuggestionCandidate,
    ITargetWithSelected,
    ITransformedSuggestion,
} from "./suggestion.typings";

/**
 * Filter all rows by column filters.
 * @param filters         The currently active filters.
 * @param selectedSources The currently selected rows by "from" column value.
 * @param rows            All rows.
 * @param fromDataset     If the current view is from the dataset, else it is from the vocabulary.
 */
export const filterRowsByColumnModifier = (
    filters: { [key: string]: string },
    selectedSources: Set<string>,
    rows: IPageSuggestion[],
    fromDataset: boolean
): IPageSuggestion[] => {
    let filteredResults = [...rows];

    Object.values(filters).forEach((filter) => {
        switch (filter) {
            case FILTER_ACTIONS.SHOW_SELECTED:
            case FILTER_ACTIONS.SHOW_UNSELECTED: {
                filteredResults = filteredResults.filter((row) =>
                    filter === FILTER_ACTIONS.SHOW_SELECTED
                        ? selectedSources.has(row.uri)
                        : !selectedSources.has(row.uri)
                );
                break;
            }

            case FILTER_ACTIONS.SHOW_MATCHES:
            case FILTER_ACTIONS.SHOW_GENERATED: {
                // This only applies in from-dataset view, since there are no auto-generated candidates in vocabulary view.
                if (fromDataset) {
                    filteredResults = filteredResults.filter((row) => {
                        const selected = selectedCandidate(row);
                        return filter === FILTER_ACTIONS.SHOW_GENERATED
                            ? selected?._autogenerated
                            : !selected?._autogenerated;
                    });
                }
                break;
            }

            case FILTER_ACTIONS.SHOW_VALUE_MAPPINGS:
            case FILTER_ACTIONS.SHOW_OBJECT_MAPPINGS: {
                const type = filter === FILTER_ACTIONS.SHOW_VALUE_MAPPINGS ? "value" : "object";
                filteredResults = filteredResults.filter((row) => {
                    const selected = selectedCandidate(row);
                    return selected && selected.type === type;
                });
                break;
            }

            case FILTER_ACTIONS.SHOW_USED_SOURCE_PATHS_ONLY:
            case FILTER_ACTIONS.SHOW_UNUSED_SOURCE_PATHS_ONLY: {
                // Only applies in from-dataset view, this information is not available in from-vocabulary view.
                if (fromDataset) {
                    const unusedOnly = filter === FILTER_ACTIONS.SHOW_UNUSED_SOURCE_PATHS_ONLY;
                    filteredResults = filteredResults.filter((row) => {
                        return (unusedOnly && !row.alreadyMapped) || (!unusedOnly && row.alreadyMapped);
                    });
                }
                break;
            }

            default:
                break;
        }
    });

    return filteredResults;
};

/** Returns the input rows sorted by the requested sort direction.
 *
 * @param rows  The rows that should be sorted.
 * @param sortDirections The column and direction to sort by.
 * @param fromDataset Is the dataset or target vocabulary view active.
 */
export const sortRows = (
    rows: IPageSuggestion[],
    sortDirections: ISortDirection,
    fromDataset: boolean
): IPageSuggestion[] => {
    const { column, modifier } = sortDirections;
    let sortFn = (item: IPageSuggestion): string | -1 => item[column];

    const sortByTargetColumn = column === "target";
    const sortBySourceColumn = column === "source";
    if ((fromDataset && sortByTargetColumn) || (!fromDataset && sortBySourceColumn)) {
        // Sorts the selected item in the 3. "target" column
        sortFn = (candidate: IPageSuggestion) => {
            const selected = selectedCandidate(candidate);
            return selected === undefined || selected._autogenerated ? -1 : itemLabel(selected);
        };
    } else if (column === "type") {
        // Type column sorter
        sortFn = (candidate) => {
            const selected = selectedCandidate(candidate);
            return selected === undefined ? -1 : selected.type;
        };
    } else if ((fromDataset && sortBySourceColumn) || (!fromDataset && sortByTargetColumn)) {
        // Sorts the items in the 1. "source" column
        sortFn = (candidate: IPageSuggestion) => itemLabel(candidate);
    }
    const lowerCasedSort = (candidate: IPageSuggestion) => {
        const sortValue = sortFn(candidate);
        return !sortValue || sortValue === -1 ? -1 : sortValue.toLowerCase();
    };
    return _.orderBy(rows, lowerCasedSort, modifier as "asc" | "desc");
};

// Returns the item label
const itemLabel = (item: ITransformedSuggestion | ISuggestionCandidate): string => {
    return item.label ? item.label : item.uri;
};

// Returns the selected candidate or the first entry if no entry is marked as selected.
export const selectedCandidate = (target: IPageSuggestion): ITargetWithSelected | undefined => {
    if (target.candidates.length > 0) {
        const selected = target.candidates.filter((candidate) => candidate._selected);
        if (selected.length > 0) {
            return selected[0];
        } else {
            return target.candidates[0];
        }
    } else {
        return undefined;
    }
};

const pathSplitRegex = /[/\\#:]+/g;
const unAllowedChars = /[<>]/g;

/** Returns a path string representation of path labels, instead of URIs
 * This is only an approximation of the much more complicated algorithm used in the backend that
 * parses the Silk paths first.
 * This version only takes the last local name of a path.
 **/
export const getLocalNameLabelFromPath = (path: string): string => {
    if (typeof path !== "string") {
        return path;
    }
    const parts = path.split(pathSplitRegex).filter((part) => part !== "");
    if (parts.length > 0) {
        const localName = parts[parts.length - 1];
        return localName.replace(unAllowedChars, "");
    } else {
        return path;
    }
};
