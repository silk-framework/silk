package org.silkframework.rule.plugins.distance.equality

import java.math.RoundingMode
import java.text.DecimalFormat

import org.silkframework.entity.Index
import org.silkframework.rule.similarity.SimpleDistanceMeasure
import org.silkframework.runtime.plugin.annotations.{Param, Plugin}
import org.silkframework.runtime.plugin.PluginCategories

@Plugin(
  id = "numericEquality",
  categories = Array("Equality", PluginCategories.recommended),
  label = "Numeric equality",
  description = NumericEqualityMetric.description
)
case class NumericEqualityMetric(@Param("The range of tolerance in floating point number comparisons. Must be 0 or a non-negative number smaller than 1.")
                                 precision: Double = 0.0) extends SimpleDistanceMeasure {
  val MAX_SIGNIFICANT_DECIMAL_PLACE = 50

  if(precision >= 1.0 || precision < 0.0) {
    throw new IllegalArgumentException("precision parameter must be 0 or a non-negative number smaller than 1.")
  }

  /** The decimal place that can definitely lead to different values when changing it. */
  @transient
  val significantDecimalPlace: Int = {
    val decimalPlace = math.ceil(math.abs(math.log10(precision))).toInt
    if(decimalPlace > MAX_SIGNIFICANT_DECIMAL_PLACE) {
      MAX_SIGNIFICANT_DECIMAL_PLACE
    } else {
      decimalPlace
    }
  }

  // A double formatter that formats the number in a way that it can be indexed
  @transient
  private val indexFormat = new ThreadLocal[DecimalFormat]{
    override def initialValue(): DecimalFormat = {
      val formatter = new DecimalFormat("#." + ("#" * significantDecimalPlace))
      formatter.setRoundingMode(RoundingMode.DOWN)
      formatter
    }
  }

  override def evaluate(str1: String, str2: String, threshold: Double): Double = {
    try {
      val d1 = str1.toDouble
      val d2 = str2.toDouble
      if (precision == 0.0) {
        if (d1 == d2) 0.0 else 1.0
      } else {
        if (math.abs(d1 - d2) <= precision) 0.0 else 1.0
      }
    } catch {
      case _: NumberFormatException =>
        1.0
    }
  }

  private def hashFormattedDouble(double: Double): Int = {
    val formatted = indexFormat.get().format(double)
    formatted.hashCode
  }

  override def emptyIndex(limit: Double): Index = {
    Index.oneDim(Set.empty)
  }

  override def indexValue(str: String, limit: Double, sourceOrTarget: Boolean): Index = {
    try {
      val doubleValue = str.toDouble
      val indexValues = if (precision == 0.0) {
        Set(doubleValue.hashCode())
      } else {
        val normalizedDoubleValue = doubleValue - (doubleValue % precision)
        val oneLower = normalizedDoubleValue - 1.1 * precision
        val oneHigher = normalizedDoubleValue + 1.1 * precision
        Set(doubleValue, oneLower, oneHigher).map(hashFormattedDouble)
      }
      Index.oneDim(indexValues)
    } catch {
      case _: NumberFormatException =>
        emptyIndex(limit)
    }
  }
}

object NumericEqualityMetric {
  final val description = """Compares values numerically instead of their string representation as the 'String Equality' operator does.
Allows to set the needed precision of the comparison. A value of 0.0 means that the values must represent exactly the same
(floating point) value, values higher than that allow for a margin of tolerance. Example: With a precision of 0.1, the
following pairs of values will be considered equal: (1.3, 1.35), (0.0, 0.9999), (0.0, -0.90001), but following pairs will NOT match:
(1.2, 1.30001), (1.0, 1.10001), (1.0, 0.89999)."""
}