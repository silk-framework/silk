package org.silkframework.execution

import org.silkframework.config.{Task, TaskSpec}
import org.silkframework.entity.paths.{Path, TypedPath}
import org.silkframework.entity.{Entity, EntitySchema}
import org.silkframework.execution.local.{GenericEntityTable, LocalEntities}
import org.silkframework.runtime.iterator.CloseableIterator
import org.silkframework.runtime.validation.ValidationException

import java.io.Closeable

/**
  * Holds entities that are exchanged between tasks.
  *
  * Must be closed after usage.
  * It's recommended to call `use` for reading the entities, which will close after usage.
  */
trait EntityHolder extends Closeable {

  /**
    * The schema of the entities
    */
  def entitySchema: EntitySchema

  /**
    * The entities in this table.
    */
  def entities: CloseableIterator[Entity]

  /**
    * Process entities and close.
    */
  def use[T](processEntities: CloseableIterator[Entity] => T): T = {
    try {
      processEntities(entities)
    } finally {
      close()
    }
  }

  def globalErrors: Seq[String] = Seq.empty

  /**
    * The task that generated this table.
    * If the entity table has been generated by a workflow this is a copy of the actual task that has been executed.
    */
  def task: Task[TaskSpec]

  /**
    * Convenience method to get either the task label if it exists or the task ID.
    * @return
    */
  def taskLabel: String = task.metaData.formattedLabel(task.id.toString)

  /**
    * Get the first entity, or None if this table is empty.
    */
  def headOption: Option[Entity]

  /**
   * Map all entities using a provided function.
   */
  def mapEntities(f: Entity => Entity): EntityHolder

  /**
   * Flat map all entities using a provided function.
   *
   * @param outputSchema The output schema of the mapped entities.
   * @param updateTask The updated task of the mapped entities.
   * @param f The mapping function.
   */
  def flatMapEntities(outputSchema: EntitySchema, updateTask: Task[TaskSpec] = task)(f: Entity => Iterator[Entity]): EntityHolder

  /**
   * Returns entities that only contain the selected paths.
   */
  def selectPaths(paths: IndexedSeq[TypedPath]): EntityHolder = {
    val updatedSchema = entitySchema.copy(typedPaths = paths)
    val indices = {
      for(path <- paths) yield {
        val index = entitySchema.typedPaths.indexOf(path)
        if(index == -1) {
          throw new ValidationException(s"Path $path does not exist on $this")
        }
        index
      }
    }
    flatMapEntities(updatedSchema) { entity =>
      Iterator(entity.copy(values = indices.map(entity.values(_)), schema = updatedSchema))
    }
  }

  def filter(f: Entity => Boolean): EntityHolder
}

trait EmptyEntityHolder extends LocalEntities {

  final def entities: CloseableIterator[Entity] = CloseableIterator(Iterator.empty)

  override def updateEntities(entities: CloseableIterator[Entity], newSchema: EntitySchema): LocalEntities = {
    if(entities.isEmpty) {
      this
    } else {
      new GenericEntityTable(entities, newSchema, task)
    }
  }

}